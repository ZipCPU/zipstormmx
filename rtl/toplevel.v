////////////////////////////////////////////////////////////////////////////////
//
// Filename:	./toplevel.v
//
// Project:	ZipSTORM-MX, an iCE40 ZipCPU demonstration project
//
// DO NOT EDIT THIS FILE!
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	autofpga autofpga -d -o . clock50.txt global.txt dlyarbiter.txt version.txt buserr.txt pic.txt pwrcount.txt spio.txt hbconsole.txt bkram.txt spixpress.txt sdram.txt sdspi.txt zipbones.txt mem_all.txt mem_flash_bkram.txt mem_bkram_only.txt mem_sdram_bkram.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2019, Gisselquist Technology, LLC
//
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of  the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
//
// License:	GPL, v3, as defined and found on www.gnu.org,
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
//
`default_nettype	none


//
// Here we declare our toplevel.v (toplevel) design module.
// All design logic must take place beneath this top level.
//
// The port declarations just copy data from the @TOP.PORTLIST
// key, or equivalently from the @MAIN.PORTLIST key if
// @TOP.PORTLIST is absent.  For those peripherals that don't need
// any top level logic, the @MAIN.PORTLIST should be sufficent,
// so the @TOP.PORTLIST key may be left undefined.
//
// The only exception is that any clocks with CLOCK.TOP tags will
// also appear in this list
//
module	toplevel(i_clk,
		// SD Card
		o_sd_sck, io_sd_cmd, io_sd,
		// Top level SDRAM I/O ports
		o_ram_clk, o_ram_cke, o_ram_cs_n, o_ram_ras_n, o_ram_cas_n,
		o_ram_we_n, o_ram_addr, o_ram_udqm, o_ram_ldqm,
		io_ram_data,
		// Top level Dual-SPI I/O ports
		o_spi_cs_n, o_spi_sck, o_spi_mosi, i_spi_miso,
		o_spi_hold, o_spi_wp,
		// UART/host to wishbone interface
		i_uart_rx, o_uart_tx,
		// SPIO interface
		io_btn, o_led);
	//
	// Declaring our input and output ports.  We listed these above,
	// now we are declaring them here.
	//
	// These declarations just copy data from the @TOP.IODECLS key,
	// or from the @MAIN.IODECL key if @TOP.IODECL is absent.  For
	// those peripherals that don't do anything at the top level,
	// the @MAIN.IODECL key should be sufficient, so the @TOP.IODECL
	// key may be left undefined.
	//
	// We start with any @CLOCK.TOP keys
	//
	input	wire		i_clk;
	// SD Card
	output	wire		o_sd_sck;
	inout	wire		io_sd_cmd;
	inout	wire	[3:0]	io_sd;
	// input	wire		i_sd_cs; // Card detect
	// input	wire		i_sd_wp; // Detect write-protect
	// SDRAM
	output	wire	o_ram_clk, o_ram_cke,
			o_ram_cs_n, o_ram_ras_n, o_ram_cas_n, o_ram_we_n;
	output	wire	[11:0]	o_ram_addr;
	output	wire		o_ram_udqm, o_ram_ldqm;
	inout	wire	[15:0]	io_ram_data;
	// Dual SPI flash
	output	wire		o_spi_cs_n;
	output	wire		o_spi_sck, o_spi_mosi;
	input	wire		i_spi_miso;
	output	wire		o_spi_hold, o_spi_wp;
	// UART/host to wishbone interface
	// (Debugging access) Serial port
	input	wire	i_uart_rx;
	output	wire	o_uart_tx;
	inout	wire	[1:0]	io_btn;
	output	wire	[1:0]	o_led;


	//
	// Declaring component data, internal wires and registers
	//
	// These declarations just copy data from the @TOP.DEFNS key
	// within the component data files.
	//
	wire		w_sd_cmd, i_sd_cmd, w_sd_sck;
	wire	[3:0]	w_sd_data, i_sd_data;
	wire	[6:0]	sd_ign;
	wire		s_clk, s_reset, pll_locked, clk_50mhz;
	// SDRAM data wires
	wire	[15:0]	w_ram_data, w_ram_data_pedge, w_ram_data_nedge,
			i_ram_data;
	wire		w_ram_drive_data,
			w_ram_cs_n, w_ram_ras_n, w_ram_cas_n, w_ram_we_n;
	wire	[11:0]	w_ram_addr;
	wire	[1:0]	w_ram_dqm;
	wire	[1:0]	w_ramclk_in_ignored;
	wire	[35:0]	w_ramctrl_in_ignored;
	wire		spi_sck;
	wire	[1:0]	i_btn;
	wire	[3:0]	w_led;


	//
	// Time to call the main module within main.v.  Remember, the purpose
	// of the main.v module is to contain all of our portable logic.
	// Things that are Xilinx (or even Altera) specific, or for that
	// matter anything that requires something other than on-off logic,
	// such as the high impedence states required by many wires, is
	// kept in this (toplevel.v) module.  Everything else goes in
	// main.v.
	//
	// We automatically place s_clk, and s_reset here.  You may need
	// to define those above.  (You did, didn't you?)  Other
	// component descriptions come from the keys @TOP.MAIN (if it
	// exists), or @MAIN.PORTLIST if it does not.
	//

	main	thedesign(s_clk, s_reset,
		// SD Card
		w_sd_sck, w_sd_cmd, w_sd_data, i_sd_cmd, i_sd_data, 1'b0,
			// SDRAM interface
			// o_ram_clk,	// SDRAM clock
			o_ram_cke,	// Clock enable
			w_ram_cs_n,	// Chip select
			w_ram_ras_n,	// Row address strobe
			w_ram_cas_n,	// Column address strobe
			w_ram_we_n,	// Write enable
			w_ram_addr,	// Address lines
			w_ram_drive_data,
			i_ram_data,	// Data lines (input)
			w_ram_data,	// Data lines (output)
			w_ram_dqm,
		// SPI flash
		o_spi_cs_n, spi_sck, o_spi_mosi, i_spi_miso,
		i_uart_rx, o_uart_tx,
		~i_btn, w_led);


	//
	// Our final section to the toplevel is used to provide all of
	// that special logic that couldnt fit in main.  This logic is
	// given by the @TOP.INSERT tag in our data files.
	//


	//
	//
	// Wires for setting up the SD Card Controller
	//
	//
	// assign io_sd_cmd = w_sd_cmd ? 1'bz:1'b0;
	// assign io_sd[0] = w_sd_data[0]? 1'bz:1'b0;
	// assign io_sd[1] = w_sd_data[1]? 1'bz:1'b0;
	// assign io_sd[2] = w_sd_data[2]? 1'bz:1'b0;
	// assign io_sd[3] = w_sd_data[3]? 1'bz:1'b0;

	iceioddr
	sdck(s_clk, 1'b1, {(2){w_sd_sck}}, sd_ign[6:5], o_sd_sck);

	iceioddr
	sdcs(s_clk, !w_sd_cmd, 2'b00, { sd_ign[4], i_sd_cmd }, io_sd_cmd);

	iceioddr
	sddata0(s_clk, !w_sd_data[0], 2'b00, { sd_ign[0], i_sd_data[0] }, io_sd[0]);

	iceioddr
	sddata1(s_clk, !w_sd_data[1], 2'b00, { sd_ign[1], i_sd_data[1] }, io_sd[1]);

	iceioddr
	sddata2(s_clk, !w_sd_data[2], 2'b00, { sd_ign[2], i_sd_data[2] }, io_sd[2]);

	iceioddr
	sddata3(s_clk, !w_sd_data[3], 2'b00, { sd_ign[3], i_sd_data[3] }, io_sd[3]);


	assign	s_reset = 1'b0; // This design requires local, not global resets

`ifdef	VERILATOR
	assign	s_clk = i_clk;
`else
	SB_PLL40_CORE #(
		.FEEDBACK_PATH("SIMPLE"),
		.DELAY_ADJUSTMENT_MODE_FEEDBACK("FIXED"),
		.DELAY_ADJUSTMENT_MODE_RELATIVE("FIXED"),
		.PLLOUT_SELECT("GENCLK"),
		.FDA_FEEDBACK(4'b1111),
		.FDA_RELATIVE(4'b1111),
		.DIVR(4'd0),		// Divide by (DIVR+1)
		.DIVQ(3'd4),		// Divide by 2^(DIVQ)
		.DIVF(7'd31),		// Multiply by (DIVF+1)
		.FILTER_RANGE(3'b010)
	) plli (
		// .PACKAGEPIN     (i_clk     ),
		.REFERENCECLK   (i_clk     ),
		.PLLOUTCORE     (clk_50mhz ),
		.LOCK           (pll_locked),
		.BYPASS         (1'b0      ),
		.RESETB         (1'b1      )
	);

	SB_GB global_buffer(clk_50mhz, s_clk);
`endif


	//
	// Tri-sate logic for the SDRAM
	//
	iceioddr
	ramck(s_clk, 1'b1, 2'b01, w_ramclk_in_ignored, o_ram_clk);

	iceioddr #(.WIDTH(4+12+2))
	ramctrl(s_clk, 1'b1,
		{(2){ w_ram_cs_n, w_ram_ras_n, w_ram_cas_n, w_ram_we_n,
			w_ram_addr, w_ram_dqm }},
			w_ramctrl_in_ignored,
		{ o_ram_cs_n, o_ram_ras_n, o_ram_cas_n, o_ram_we_n,
			o_ram_addr, o_ram_udqm, o_ram_ldqm });

	iceioddr #(.WIDTH(16))
	ramio(s_clk, w_ram_drive_data, { w_ram_data, w_ram_data },
			{ w_ram_data_pedge, w_ram_data_nedge },
			io_ram_data);

	assign	i_ram_data = w_ram_data_nedge;

	//
	//
	// Wires for setting up the SPI flash wishbone peripheral
	//
	//
	oclkddr spi_ddr_sck(s_clk, {!spi_sck, 1'b1}, o_spi_sck);

	assign	o_spi_hold = 1;
	assign	o_spi_wp   = 1;

	//
	// Special purpose I/O (LEDs and buttons)
	//
	// assign	io_btn[0] = (o_led[0] ? 1'b0 : 1'bz);
	// assign	io_btn[1] = (o_led[1] ? 1'b0 : 1'bz);
	//
	assign	o_led = ~w_led[3:2] & (pll_locked ? 2'b11 : 2'b00);

	SB_IO #(.PULLUP(1'b1), .PIN_TYPE(6'b1010_01))
	ledio0 (.PACKAGE_PIN(io_btn[0]),
		.OUTPUT_ENABLE(w_led[0]),
		.D_OUT_0(1'b0),
		.D_IN_0(i_btn[0]));

	SB_IO #(.PULLUP(1'b1), .PIN_TYPE(6'b1010_01))
	ledio1 (.PACKAGE_PIN(io_btn[1]),
		.OUTPUT_ENABLE(w_led[1]),
		.D_OUT_0(1'b0),
		.D_IN_0(i_btn[1]));




endmodule // end of toplevel.v module definition
